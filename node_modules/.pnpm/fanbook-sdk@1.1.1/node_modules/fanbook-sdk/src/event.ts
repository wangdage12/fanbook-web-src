import {
  BridgeEventParams,
  BridgeType,
  FB_MP_WEB_BRIDGE_HEARTBEAT,
  FB_MP_WEB_BRIDGE_HEARTBEAT_RETURN,
  FB_MP_WEB_SDK_BRIDGE_CLOSE,
  FB_MP_WEB_SDK_BRIDGE_MP_GET_URL,
  FB_MP_WEB_SDK_BRIDGE_MP_TO_PLACEHOLDER,
  FbBridge,
} from './bridge'

const FB_EVENT_CALL_HOST = 'fb-web-sdk-call-host'

export const ON_PROXY_HEARTBEAT = 'onProxyHeartbeat'
export const ON_MINI_PROGRAM_CLOSE = 'onMiniProgramClose'

export interface FbEventReturnParams<R = any> {
  result?: R
  error?: string
}

export interface FbEventParams<R = any> extends FbEventReturnParams<R>, BridgeEventParams {
  // 回调 key
  key?: string
  // 操作名称
  operate?: string
  // 操作参数
  params?: any[]
}

export type FbEventMode = 'host' | 'proxy' | 'mini-program'

function errorToString(err: any) {
  return (
    err instanceof Error ? err.message
    : ['string', 'number'].includes(typeof err) ? `${err as string | number}`
    : 'error'
  )
}

export interface FbEventInitParams {
  uniqueId?: string
  channelName?: string
  mode: FbEventMode
}

export class FbEvent {
  bridge?: FbBridge<FbEventParams>
  uniqueId?: string
  channelName?: string

  private mode: FbEventMode

  private events: { [eventName: string]: ((data: any) => void)[] } = {}

  handler: {
    [eventName: string]: (
      eventParam: {
        from: string
      },
      ...args: any[]
    ) => any | Promise<any>
  }

  constructor(
    { uniqueId, channelName, mode }: FbEventInitParams,
    handler?: {
      [eventName: string]: (
        eventParam: {
          from: string
        },
        ...args: any[]
      ) => any | Promise<any>
    }
  ) {
    this.mode = mode
    this.uniqueId = uniqueId
    this.channelName = channelName
    this.handler = handler ?? {}
  }

  addTabView(uniqueId: string, url: string) {
    this.bridge?.addBridge({ uniqueId, type: BridgeType.Tab, url })
  }
  removeTabView(uniqueId: string) {
    this.bridge?.removeBridge(uniqueId)
  }
  /**
   * 需要在 iframe 设置 src 前调用
   */
  addSubPage(uniqueId: string, iframe: HTMLIFrameElement, url?: string) {
    this.bridge?.addBridge({ uniqueId, type: BridgeType.Iframe, iframeElem: iframe, url })
  }

  private _initPromise?: Promise<FbEventReturnParams<void>>

  init() {
    if (this._initPromise) return this._initPromise

    this._initPromise = new Promise<FbEventReturnParams<void>>(resolve => {
      // 如果是小程序，需要判断是否在 iframe 内部
      if (this.mode === 'mini-program') {
        if (window.self === window.top) {
          resolve({ error: 'not in fanbook mp' })
          return
        }
      }

      this.bridge = new FbBridge<FbEventParams>({ channelName: this.channelName, messageHandler: this.handleMessage.bind(this) })
      this.bridge
        .init(this.uniqueId)
        .then(uniqueId => {
          this.uniqueId = uniqueId
          // 如果是 proxy 模式，需要添加宿主桥接层
          if (this.mode === 'proxy' && this.channelName) {
            this.bridge?.addBridge({ uniqueId: this.channelName, type: BridgeType.Tab })
            // 代理心跳
            this.proxyHeartbeat()
          }
          resolve({ result: undefined })
        })
        .catch(err => {
          resolve({ error: errorToString(err) })
        })
    })

    return this._initPromise
  }

  private proxyHeartbeat() {
    const key = `${FB_MP_WEB_BRIDGE_HEARTBEAT}-${Date.now()}`
    this.bridge?.send({
      eventType: FB_MP_WEB_BRIDGE_HEARTBEAT,
      from: this.uniqueId,
      to: this.channelName,
      key,
    } as FbEventParams)
    const timeout = setTimeout(() => {
      this.handler[ON_PROXY_HEARTBEAT]?.({ from: this.uniqueId ?? '' }, { error: 'timeout' })
      this.off(key)
    }, 5000)
    this.once<void>(key, ({ error }) => {
      clearTimeout(timeout)
      if (error) {
        this.handler[ON_PROXY_HEARTBEAT]?.({ from: this.uniqueId ?? '' }, { error })
        return
      }
      setTimeout(() => {
        this.proxyHeartbeat()
      }, 30000)
    })
  }

  private handleMessage<T>(data: FbEventParams<T>) {
    if (typeof data !== 'object') return
    const { eventType, from, key, result, error } = data
    switch (eventType) {
      case FB_EVENT_CALL_HOST:
        this.hostHandle(data)
        return
      case ON_MINI_PROGRAM_CLOSE:
        this.handler[ON_MINI_PROGRAM_CLOSE]?.({ from })
        return
      // 仅在 host 模式下接收
      case FB_MP_WEB_SDK_BRIDGE_CLOSE:
        this.handler[FB_MP_WEB_SDK_BRIDGE_CLOSE]?.({ from })
        return
      case FB_MP_WEB_SDK_BRIDGE_MP_GET_URL:
      case FB_MP_WEB_BRIDGE_HEARTBEAT_RETURN:
      default:
        break
    }
    if (!key) return
    this.emit(key, { result, error })
  }

  destroy() {
    if (!['host', 'proxy'].includes(this.mode)) {
      throw new Error('not in host mode or proxy mode')
    }
    this.bridge?.destroy(this.mode === 'proxy' ? this.channelName : undefined)
  }

  async getMiniProgramUrl() {
    if (this.mode !== 'proxy') {
      throw new Error('not in proxy mode')
    }
    const key = `${FB_MP_WEB_SDK_BRIDGE_MP_GET_URL}-${Date.now()}`
    this.bridge?.send({
      eventType: FB_MP_WEB_SDK_BRIDGE_MP_GET_URL,
      from: this.uniqueId,
      to: this.channelName,
      key,
    } as FbEventParams)
    return new Promise<FbEventReturnParams<string>>(resolve => {
      this.once<string>(key, resolve)
    })
  }

  async closeWindow() {
    if (this.mode !== 'mini-program') {
      throw new Error('not in mini-program mode')
    }
    if (!this.uniqueId) {
      return { error: 'sdk not init' }
    }
    this.bridge?.send({
      eventType: ON_MINI_PROGRAM_CLOSE,
      from: this.uniqueId,
      to: FB_MP_WEB_SDK_BRIDGE_MP_TO_PLACEHOLDER,
    })
  }

  async callHost<T>(operate: string, ...params: any[]) {
    if (this.mode !== 'mini-program') {
      throw new Error('not in mini-program mode')
    }
    if (!this.uniqueId) {
      return { error: 'sdk not init' }
    }
    const key = `${operate}-${Date.now()}`
    this.bridge?.send({
      eventType: FB_EVENT_CALL_HOST,
      from: this.uniqueId,
      to: FB_MP_WEB_SDK_BRIDGE_MP_TO_PLACEHOLDER,
      operate,
      key,
      params,
    })
    return new Promise<FbEventReturnParams<T>>(resolve => {
      this.once<T>(key, resolve)
    })
  }

  private async hostHandle<T>(data: FbEventParams<T>) {
    switch (this.mode) {
      case 'host': {
        const { operate, params, from, to, ..._data } = data
        const fn = this.handler?.[operate ?? '']
        if (fn) {
          try {
            const result = await fn({ from }, ...(params ?? []))
            this.bridge?.send({
              ..._data,
              to: from,
              from: to,
              result,
            })
          } catch (err) {
            this.bridge?.send({
              ..._data,
              to: from,
              from: to,
              error: errorToString(err),
            })
          }
        } else {
          this.bridge?.send({
            ..._data,
            to: from,
            from: to,
            error: `${operate} not found`,
          })
        }
        break
      }
      case 'proxy': {
        const { operate, params, from, to, key, result, error, ..._data } = data
        if (!this.channelName) {
          this.bridge?.send({
            ..._data,
            key,
            to: from,
            from: to,
            error: 'host not found',
          })
          return
        }
        if (operate && key) {
          this.once<T>(key, data => {
            const { result, error } = data
            // 转发给小程序
            this.bridge?.send({
              ..._data,
              key,
              to: from,
              from: to,
              result,
              error,
            })
          })
          // 转发给 host
          this.bridge?.send({
            ..._data,
            key,
            to: this.channelName,
            from: to,
            operate,
            params,
          })
          return
        }
        key && this.emit(key, { result, error })
        break
      }
      case 'mini-program': {
        const { key, result, error } = data
        key && this.emit(key, { result, error })
        break
      }
      default:
        break
    }
  }

  once<T>(eventName: string, callback: (data: FbEventReturnParams<T>) => void) {
    const onceCallback = (data: FbEventReturnParams<T>) => {
      callback(data)
      this.off(eventName, onceCallback)
    }
    this.on(eventName, onceCallback)
  }

  on<T>(eventName: string, callback: (data: FbEventReturnParams<T>) => void) {
    if (!this.events[eventName]) {
      this.events[eventName] = []
    }
    this.events[eventName].push(callback)
  }

  off<T>(eventName: string, callback?: (data: FbEventReturnParams<T>) => void) {
    const eventCallbacks = this.events[eventName]
    if (eventCallbacks) {
      if (callback) {
        this.events[eventName] = eventCallbacks.filter(cb => cb !== callback)
      } else {
        this.events[eventName] = []
      }
    }
    if (this.events[eventName].length === 0) {
      delete this.events[eventName]
    }
  }

  emit<T>(eventName: string, data: FbEventReturnParams<T>) {
    const eventCallbacks = this.events[eventName]
    if (eventCallbacks) {
      eventCallbacks.forEach(callback => {
        callback(data)
      })
    }
  }
}
