import { BroadcastChannel } from 'broadcast-channel'

export const FB_MP_WEB_SDK_BRIDGE_MP_TO_PLACEHOLDER = 'fb-mp-web-sdk-bridge-mp-to-placeholder'

export const FB_MP_WEB_SDK_BRIDGE_CLOSE = 'fb-mp-web-sdk-bridge-close'
export const FB_MP_WEB_SDK_BRIDGE_MP_GET_URL = 'fb-mp-web-sdk-bridge-get-url'

export const FB_MP_WEB_BRIDGE_HEARTBEAT = 'fb-mp-web-bridge-heartbeat'
export const FB_MP_WEB_BRIDGE_HEARTBEAT_RETURN = 'fb-mp-web-bridge-heartbeat-return'

const FB_MP_WEB_SDK_BRIDGE_IFRAME_GET_ID = 'fb-mp-web-sdk-bridge-get-id'
const FB_MP_WEB_SDK_BRIDGE_IFRAME_SET_ID = 'fb-mp-web-sdk-bridge-set-id'

export enum BridgeType {
  Iframe = 'iframe',
  Tab = 'tab',
}

type FbBridgeParamsIframe = {
  uniqueId: string
  type: BridgeType.Iframe
  iframeElem: HTMLIFrameElement
  url?: string
}

type FbBridgeParamsTab = {
  uniqueId: string
  type: BridgeType.Tab
  url?: string
}

type FbBridgeParams = FbBridgeParamsIframe | FbBridgeParamsTab

export interface BridgeEventParams {
  eventType: string
  to: string
  from: string
}

export function optimizedMD5(input: string) {
  let hash = 0
  const windowSize = 1000
  for (let i = 0; i < input.length; i += windowSize) {
    let sum = 0
    for (let j = i; j < i + windowSize && j < input.length; j++) {
      sum += input.charCodeAt(j)
    }
    hash ^= sum
  }
  return hash.toString(16)
}

function wrapMessage(data: unknown) {
  const hash = optimizedMD5(JSON.stringify(data))
  return {
    hash,
    data,
  }
}

function unwrapMessage<T>(message: { hash: string; data: T }): T | null {
  const { hash, data } = message
  const _hash = optimizedMD5(JSON.stringify(data ?? ''))
  if (hash !== _hash) {
    return null
  }
  return data
}

export class FbBridge<T extends BridgeEventParams> {
  /**
   * 桥接层 id
   */
  uniqueId?: string
  /**
   * 单项通信 id 仅在 iframe 内部才会出现这种情况
   */
  private to?: string

  messageHandler?: (data: T) => void

  bridges: Map<string, FbBridgeParams> = new Map()

  iframeBridges: WeakMap<Window, string> = new WeakMap()

  channel?: BroadcastChannel

  _initResolve?: (uniqueId: string) => void

  _timers: { [key: string]: ReturnType<typeof setTimeout> } = {}

  constructor({ channelName, messageHandler }: { channelName?: string; messageHandler?: (data: T) => void }) {
    if (channelName) {
      this.channel = new BroadcastChannel(channelName, {})
      this.channel.addEventListener('message', data => {
        try {
          const _data = unwrapMessage<T>(data)
          if (!_data) return
          const { to, from, eventType } = _data

          if (eventType === FB_MP_WEB_SDK_BRIDGE_CLOSE) {
            // 来自弹窗的关闭消息
            if (to === this.uniqueId) {
              if (this._timers[from]) {
                clearTimeout(this._timers[from])
              }
              // 5 分钟后删除该桥接层信息
              this._timers[from] = setTimeout(() => {
                delete this._timers[from]
                this.removeBridge(from)
                this.messageHandler?.({ eventType: FB_MP_WEB_SDK_BRIDGE_CLOSE, to, from } as T)
              }, 60000)
            }
            // 来自父页面的关闭消息
            if (!to && from === channelName) {
              window.close()
            }
            return
          }
          // 心跳
          if (eventType === FB_MP_WEB_BRIDGE_HEARTBEAT) {
            if (to === this.uniqueId) {
              // 移除之前的删除桥接层信息的定时器
              if (this._timers[from]) {
                clearTimeout(this._timers[from])
                delete this._timers[from]
              }
              const error = this.bridges.has(from) ? undefined : 'not found'
              this.channel?.postMessage(wrapMessage({ ..._data, eventType: FB_MP_WEB_BRIDGE_HEARTBEAT_RETURN, to: from, from: to, error }))
              return
            }
          }

          // 请求 小程序 url
          if (eventType === FB_MP_WEB_SDK_BRIDGE_MP_GET_URL) {
            const bridge = this.bridges.get(from)
            if (to === this.uniqueId && bridge && bridge.url) {
              this.send({ ..._data, to: from, from: to, result: bridge.url })
              return
            }
          }

          if (to !== this.uniqueId) return
          this.messageHandler?.(_data)
        } catch (error) {
          console.error(error)
        }
      })
    }
    window.addEventListener('message', event => {
      const { data, source } = event
      const _data = unwrapMessage<T>(data)
      if (_data) {
        const { to, from, eventType } = _data
        /**
         * iframe 请求 id
         */
        if (eventType === FB_MP_WEB_SDK_BRIDGE_IFRAME_GET_ID) {
          // 不是 iframe 发送的消息
          if (!source) return
          const uniqueId = this.iframeBridges.get(source as Window)
          // 不是注册 iframe 发送的消息
          if (!uniqueId) return
          ;(source as Window).postMessage(wrapMessage({ to: uniqueId, from: this.uniqueId, eventType: FB_MP_WEB_SDK_BRIDGE_IFRAME_SET_ID }), '*')
          return
        }
        /**
         * iframe 设置 id
         */
        if (eventType === FB_MP_WEB_SDK_BRIDGE_IFRAME_SET_ID) {
          this.uniqueId = to
          this.to = from
          this._initResolve?.(this.uniqueId)
          this._initResolve = undefined
          return
        }

        if (to !== this.uniqueId) return
        this.messageHandler?.(_data)
      }
    })
    this.messageHandler = messageHandler
  }
  /**
   * 桥接层 id 不存在时, 会向父页面发送消息, 父页面会返回注册的桥接层 id, 仅在 iframe 内部才会出现这种情况
   * @param uniqueId 桥接层 id
   */
  async init(uniqueId?: string) {
    if (uniqueId) {
      this.uniqueId = uniqueId
      return uniqueId
    }
    return new Promise<string>(resolve => {
      window.parent.postMessage(
        wrapMessage({
          eventType: FB_MP_WEB_SDK_BRIDGE_IFRAME_GET_ID,
        }),
        '*'
      )
      this._initResolve = resolve
    })
  }

  addBridge(bridge: FbBridgeParams) {
    this.bridges.set(bridge.uniqueId, bridge)
    if (bridge.type === BridgeType.Iframe && bridge.iframeElem.contentWindow) {
      this.iframeBridges.set(bridge.iframeElem.contentWindow, bridge.uniqueId)
    }
  }

  removeBridge(uniqueId: string) {
    this.bridges.delete(uniqueId)
  }
  // 若有 to, 则是发送给父页面, 否则是父页面广播
  destroy(to?: string) {
    this.channel?.postMessage(wrapMessage({ eventType: FB_MP_WEB_SDK_BRIDGE_CLOSE, to, from: this.uniqueId }))
  }

  send(data: T) {
    const { to } = data
    const bridge = this.bridges.get(data.to)
    // 如果没有找到对应的 bridge, 就是 iframe 内部向父级页面发送消息
    if (!bridge) {
      if (to === FB_MP_WEB_SDK_BRIDGE_MP_TO_PLACEHOLDER && this.to) {
        window.top?.postMessage(wrapMessage({ ...data, to: this.to }), '*')
      }
      return
    }

    if (bridge.type === BridgeType.Iframe) {
      const { iframeElem } = bridge as FbBridgeParamsIframe
      iframeElem.contentWindow?.postMessage(wrapMessage(data), '*')
    } else {
      this.channel?.postMessage(wrapMessage(data))
    }
  }
}
